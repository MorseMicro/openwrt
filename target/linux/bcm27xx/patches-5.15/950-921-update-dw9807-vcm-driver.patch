This Patch brings DW9807/17 lens module driver from RaspberryPi kernel repo.
This patch is generated by copying the dw9807-vcm.c from RaspberryPi kernel 
repo, replacing it with existing one and generating the patch.
diff --git a/drivers/media/i2c/dw9807-vcm.c b/drivers/media/i2c/dw9807-vcm.c
index 95e06f13b..c9fa79aa3 100644
--- a/drivers/media/i2c/dw9807-vcm.c
+++ b/drivers/media/i2c/dw9807-vcm.c
@@ -1,12 +1,21 @@
 // SPDX-License-Identifier: GPL-2.0
 // Copyright (C) 2018 Intel Corporation
 
+/*
+ * DW9807 is a 10-bit DAC driver, capable of sinking up to 100mA.
+ *
+ * DW9817 is a bidirectional 10-bit driver, driving up to +/- 100mA.
+ * Operationally it is identical to DW9807, except that the idle position is
+ * the mid-point, not 0.
+ */
+
 #include <linux/acpi.h>
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 
@@ -38,10 +47,22 @@
 
 #define MAX_RETRY		10
 
+#define DW9807_PW_MIN_DELAY_US		100
+#define DW9807_PW_DELAY_RANGE_US	10
+
+struct dw9807_cfg {
+	unsigned int idle_pos;
+	unsigned int default_pos;
+};
+
 struct dw9807_device {
 	struct v4l2_ctrl_handler ctrls_vcm;
 	struct v4l2_subdev sd;
 	u16 current_val;
+	u16 idle_pos;
+	struct regulator *vdd;
+	struct notifier_block notifier;
+	bool first;
 };
 
 static inline struct dw9807_device *sd_to_dw9807_vcm(
@@ -109,6 +130,102 @@ static int dw9807_set_dac(struct i2c_client *client, u16 data)
 	return 0;
 }
 
+/*
+ * The lens position is gradually moved in units of DW9807_CTRL_STEPS,
+ * to make the movements smoothly. In all cases, even when "start" and
+ * "end" are the same, the lens will be set to the "end" position.
+ *
+ * (We don't use hardware slew rate control, because it differs widely
+ * between otherwise-compatible ICs, and may need lens-specific tuning.)
+ */
+static int dw9807_ramp(struct i2c_client *client, int start, int end)
+{
+	int step, val, ret;
+
+	if (start < end)
+		step = DW9807_CTRL_STEPS;
+	else
+		step = -DW9807_CTRL_STEPS;
+
+	val = start;
+	while (true) {
+		val += step;
+		if (step * (val - end) >= 0)
+			val = end;
+		ret = dw9807_set_dac(client, val);
+		if (ret)
+			dev_err_ratelimited(&client->dev, "%s I2C failure: %d",
+					    __func__, ret);
+		if (val == end)
+			break;
+		usleep_range(DW9807_CTRL_DELAY_US, DW9807_CTRL_DELAY_US + 10);
+	}
+
+	return ret;
+}
+
+static int dw9807_active(struct dw9807_device *dw9807_dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dw9807_dev->sd);
+	const char tx_data[2] = { DW9807_CTL_ADDR, 0x00 };
+	int ret;
+
+	/* Power on */
+	ret = i2c_master_send(client, tx_data, sizeof(tx_data));
+	if (ret < 0) {
+		dev_err(&client->dev, "I2C write CTL fail ret = %d\n", ret);
+		return ret;
+	}
+
+	dw9807_dev->first = true;
+
+	return dw9807_ramp(client, dw9807_dev->idle_pos, dw9807_dev->current_val);
+}
+
+static int dw9807_standby(struct dw9807_device *dw9807_dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dw9807_dev->sd);
+	const char tx_data[2] = { DW9807_CTL_ADDR, 0x01 };
+	int ret;
+
+	if (abs(dw9807_dev->current_val - dw9807_dev->idle_pos) > DW9807_CTRL_STEPS)
+		dw9807_ramp(client, dw9807_dev->current_val, dw9807_dev->idle_pos);
+
+	/* Power down */
+	ret = i2c_master_send(client, tx_data, sizeof(tx_data));
+	if (ret < 0) {
+		dev_err(&client->dev, "I2C write CTL fail ret = %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dw9807_regulator_event(struct notifier_block *nb,
+				  unsigned long action, void *data)
+{
+	struct dw9807_device *dw9807_dev =
+		container_of(nb, struct dw9807_device, notifier);
+
+	if (action & REGULATOR_EVENT_ENABLE) {
+		/*
+		 * Initialisation delay between VDD low->high and the moment
+		 * when the i2c command is available.
+		 * From the datasheet, it should be 10ms + 2ms (max power
+		 * up sequence duration)
+		 */
+		usleep_range(DW9807_PW_MIN_DELAY_US,
+			     DW9807_PW_MIN_DELAY_US +
+			     DW9807_PW_DELAY_RANGE_US);
+
+		dw9807_active(dw9807_dev);
+	} else if (action & REGULATOR_EVENT_PRE_DISABLE) {
+		dw9807_standby(dw9807_dev);
+	}
+
+	return 0;
+}
+
 static int dw9807_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct dw9807_device *dev_vcm = container_of(ctrl->handler,
@@ -116,9 +233,11 @@ static int dw9807_set_ctrl(struct v4l2_ctrl *ctrl)
 
 	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE) {
 		struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+		int start = (dev_vcm->first) ? dev_vcm->current_val : ctrl->val;
 
+		dev_vcm->first = false;
 		dev_vcm->current_val = ctrl->val;
-		return dw9807_set_dac(client, ctrl->val);
+		return dw9807_ramp(client, start, ctrl->val);
 	}
 
 	return -EINVAL;
@@ -163,7 +282,8 @@ static int dw9807_init_controls(struct dw9807_device *dev_vcm)
 	v4l2_ctrl_handler_init(hdl, 1);
 
 	v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE,
-			  0, DW9807_MAX_FOCUS_POS, DW9807_FOCUS_STEPS, 0);
+			  0, DW9807_MAX_FOCUS_POS, DW9807_FOCUS_STEPS,
+			  dev_vcm->current_val);
 
 	dev_vcm->sd.ctrl_handler = hdl;
 	if (hdl->error) {
@@ -175,9 +295,32 @@ static int dw9807_init_controls(struct dw9807_device *dev_vcm)
 	return 0;
 }
 
+/* Compatible devices; in fact there are many similar chips.
+ * "data" holds the powered-off (zero current) lens position and a
+ * default/initial control value (which need not be the same as the powered-off
+ * value).
+ */
+static const struct dw9807_cfg dw9807_cfg = {
+	.idle_pos = 0,
+	.default_pos = 0
+};
+
+static const struct dw9807_cfg dw9817_cfg = {
+	.idle_pos = 512,
+	.default_pos = 480,
+};
+
+static const struct of_device_id dw9807_of_table[] = {
+	{ .compatible = "dongwoon,dw9807-vcm", .data = &dw9807_cfg },
+	{ .compatible = "dongwoon,dw9817-vcm", .data = &dw9817_cfg },
+	{ /* sentinel */ }
+};
+
 static int dw9807_probe(struct i2c_client *client)
 {
 	struct dw9807_device *dw9807_dev;
+	const struct of_device_id *match;
+	const struct dw9807_cfg *cfg;
 	int rval;
 
 	dw9807_dev = devm_kzalloc(&client->dev, sizeof(*dw9807_dev),
@@ -185,6 +328,31 @@ static int dw9807_probe(struct i2c_client *client)
 	if (dw9807_dev == NULL)
 		return -ENOMEM;
 
+	dw9807_dev->vdd = devm_regulator_get_optional(&client->dev, "VDD");
+	if (IS_ERR(dw9807_dev->vdd)) {
+		if (PTR_ERR(dw9807_dev->vdd) != -ENODEV)
+			return PTR_ERR(dw9807_dev->vdd);
+
+		dw9807_dev->vdd = NULL;
+	} else {
+		dw9807_dev->notifier.notifier_call = dw9807_regulator_event;
+
+		rval = regulator_register_notifier(dw9807_dev->vdd,
+						   &dw9807_dev->notifier);
+		if (rval) {
+			dev_err(&client->dev,
+				"could not register regulator notifier\n");
+			return rval;
+		}
+	}
+
+	match = i2c_of_match_device(dw9807_of_table, client);
+	if (match) {
+		cfg = (const struct dw9807_cfg *)match->data;
+		dw9807_dev->idle_pos = cfg->idle_pos;
+		dw9807_dev->current_val = cfg->default_pos;
+	}
+
 	v4l2_i2c_subdev_init(&dw9807_dev->sd, client, &dw9807_ops);
 	dw9807_dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dw9807_dev->sd.internal_ops = &dw9807_int_ops;
@@ -203,7 +371,8 @@ static int dw9807_probe(struct i2c_client *client)
 	if (rval < 0)
 		goto err_cleanup;
 
-	pm_runtime_set_active(&client->dev);
+	if (!dw9807_dev->vdd)
+		pm_runtime_set_active(&client->dev);
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
 
@@ -221,6 +390,10 @@ static int dw9807_remove(struct i2c_client *client)
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct dw9807_device *dw9807_dev = sd_to_dw9807_vcm(sd);
 
+	if (dw9807_dev->vdd)
+		regulator_unregister_notifier(dw9807_dev->vdd,
+					      &dw9807_dev->notifier);
+
 	pm_runtime_disable(&client->dev);
 
 	dw9807_subdev_cleanup(dw9807_dev);
@@ -238,25 +411,11 @@ static int __maybe_unused dw9807_vcm_suspend(struct device *dev)
 	struct i2c_client *client = to_i2c_client(dev);
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct dw9807_device *dw9807_dev = sd_to_dw9807_vcm(sd);
-	const char tx_data[2] = { DW9807_CTL_ADDR, 0x01 };
-	int ret, val;
-
-	for (val = dw9807_dev->current_val & ~(DW9807_CTRL_STEPS - 1);
-	     val >= 0; val -= DW9807_CTRL_STEPS) {
-		ret = dw9807_set_dac(client, val);
-		if (ret)
-			dev_err_once(dev, "%s I2C failure: %d", __func__, ret);
-		usleep_range(DW9807_CTRL_DELAY_US, DW9807_CTRL_DELAY_US + 10);
-	}
 
-	/* Power down */
-	ret = i2c_master_send(client, tx_data, sizeof(tx_data));
-	if (ret < 0) {
-		dev_err(&client->dev, "I2C write CTL fail ret = %d\n", ret);
-		return ret;
-	}
+	if (dw9807_dev->vdd)
+		return regulator_disable(dw9807_dev->vdd);
 
-	return 0;
+	return dw9807_standby(dw9807_dev);
 }
 
 /*
@@ -270,33 +429,13 @@ static int  __maybe_unused dw9807_vcm_resume(struct device *dev)
 	struct i2c_client *client = to_i2c_client(dev);
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct dw9807_device *dw9807_dev = sd_to_dw9807_vcm(sd);
-	const char tx_data[2] = { DW9807_CTL_ADDR, 0x00 };
-	int ret, val;
-
-	/* Power on */
-	ret = i2c_master_send(client, tx_data, sizeof(tx_data));
-	if (ret < 0) {
-		dev_err(&client->dev, "I2C write CTL fail ret = %d\n", ret);
-		return ret;
-	}
 
-	for (val = dw9807_dev->current_val % DW9807_CTRL_STEPS;
-	     val < dw9807_dev->current_val + DW9807_CTRL_STEPS - 1;
-	     val += DW9807_CTRL_STEPS) {
-		ret = dw9807_set_dac(client, val);
-		if (ret)
-			dev_err_ratelimited(dev, "%s I2C failure: %d",
-						__func__, ret);
-		usleep_range(DW9807_CTRL_DELAY_US, DW9807_CTRL_DELAY_US + 10);
-	}
+	if (dw9807_dev->vdd)
+		return regulator_enable(dw9807_dev->vdd);
 
-	return 0;
+	return dw9807_active(dw9807_dev);
 }
 
-static const struct of_device_id dw9807_of_table[] = {
-	{ .compatible = "dongwoon,dw9807-vcm" },
-	{ /* sentinel */ }
-};
 MODULE_DEVICE_TABLE(of, dw9807_of_table);
 
 static const struct dev_pm_ops dw9807_pm_ops = {
